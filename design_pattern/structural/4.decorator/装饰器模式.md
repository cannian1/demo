# 装饰模式

## 优点：
- 对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。 
- 可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。 
- 可以对一个对象进行多次装饰。 
- 具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。

## 缺点：
- 使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。 
- 装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。

## 适用场景
- 动态、透明的方式给单个对象添加职责。
- 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。
- 装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。

## 应用实例
孙悟空的72变：孙悟空（ConcreteComponent）通过变化（Decorator）获得新的能力。
画框装饰画：一幅画（ConcreteComponent）可以通过添加玻璃（ConcreteDecorator）和画框（ConcreteDecorator）来增强其展示效果。